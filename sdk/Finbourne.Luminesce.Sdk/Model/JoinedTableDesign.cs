/*
 * FINBOURNE Luminesce Web API
 *
 * Contact: info@finbourne.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = Finbourne.Luminesce.Sdk.Client.OpenAPIDateConverter;

namespace Finbourne.Luminesce.Sdk.Model
{
    /// <summary>
    /// Treatment of a joined-to-table a QueryDesign
    /// </summary>
    [DataContract(Name = "JoinedTableDesign")]
    public partial class JoinedTableDesign : IEquatable<JoinedTableDesign>, IValidatableObject
    {

        /// <summary>
        /// Gets or Sets JoinType
        /// </summary>
        [DataMember(Name = "joinType", IsRequired = true, EmitDefaultValue = true)]
        public DesignJoinType JoinType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="JoinedTableDesign" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected JoinedTableDesign() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="JoinedTableDesign" /> class.
        /// </summary>
        /// <param name="joinedTableName">Name of the table on the right side of the join (required).</param>
        /// <param name="joinedTableAlias">Alias for the table on the right side of the join (required).</param>
        /// <param name="leftTableAlias">Alias for the table on the left side of the join (required).</param>
        /// <param name="joinType">joinType (required).</param>
        /// <param name="onClauseTerms">Filter clauses to apply to this join in the on clause (required).</param>
        /// <param name="rightTableAvailableFields">Fields that are known to be available for design when parsing SQL, of the right hand table.</param>
        public JoinedTableDesign(string joinedTableName = default(string), string joinedTableAlias = default(string), string leftTableAlias = default(string), DesignJoinType joinType = default(DesignJoinType), List<OnClauseTermDesign> onClauseTerms = default(List<OnClauseTermDesign>), List<AvailableField> rightTableAvailableFields = default(List<AvailableField>))
        {
            // to ensure "joinedTableName" is required (not null)
            if (joinedTableName == null)
            {
                throw new ArgumentNullException("joinedTableName is a required property for JoinedTableDesign and cannot be null");
            }
            this.JoinedTableName = joinedTableName;
            // to ensure "joinedTableAlias" is required (not null)
            if (joinedTableAlias == null)
            {
                throw new ArgumentNullException("joinedTableAlias is a required property for JoinedTableDesign and cannot be null");
            }
            this.JoinedTableAlias = joinedTableAlias;
            // to ensure "leftTableAlias" is required (not null)
            if (leftTableAlias == null)
            {
                throw new ArgumentNullException("leftTableAlias is a required property for JoinedTableDesign and cannot be null");
            }
            this.LeftTableAlias = leftTableAlias;
            this.JoinType = joinType;
            // to ensure "onClauseTerms" is required (not null)
            if (onClauseTerms == null)
            {
                throw new ArgumentNullException("onClauseTerms is a required property for JoinedTableDesign and cannot be null");
            }
            this.OnClauseTerms = onClauseTerms;
            this.RightTableAvailableFields = rightTableAvailableFields;
        }

        /// <summary>
        /// Name of the table on the right side of the join
        /// </summary>
        /// <value>Name of the table on the right side of the join</value>
        [DataMember(Name = "joinedTableName", IsRequired = true, EmitDefaultValue = true)]
        public string JoinedTableName { get; set; }

        /// <summary>
        /// Alias for the table on the right side of the join
        /// </summary>
        /// <value>Alias for the table on the right side of the join</value>
        [DataMember(Name = "joinedTableAlias", IsRequired = true, EmitDefaultValue = true)]
        public string JoinedTableAlias { get; set; }

        /// <summary>
        /// Alias for the table on the left side of the join
        /// </summary>
        /// <value>Alias for the table on the left side of the join</value>
        [DataMember(Name = "leftTableAlias", IsRequired = true, EmitDefaultValue = true)]
        public string LeftTableAlias { get; set; }

        /// <summary>
        /// Filter clauses to apply to this join in the on clause
        /// </summary>
        /// <value>Filter clauses to apply to this join in the on clause</value>
        [DataMember(Name = "onClauseTerms", IsRequired = true, EmitDefaultValue = true)]
        public List<OnClauseTermDesign> OnClauseTerms { get; set; }

        /// <summary>
        /// Fields that are known to be available for design when parsing SQL, of the right hand table
        /// </summary>
        /// <value>Fields that are known to be available for design when parsing SQL, of the right hand table</value>
        [DataMember(Name = "rightTableAvailableFields", EmitDefaultValue = true)]
        public List<AvailableField> RightTableAvailableFields { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class JoinedTableDesign {\n");
            sb.Append("  JoinedTableName: ").Append(JoinedTableName).Append("\n");
            sb.Append("  JoinedTableAlias: ").Append(JoinedTableAlias).Append("\n");
            sb.Append("  LeftTableAlias: ").Append(LeftTableAlias).Append("\n");
            sb.Append("  JoinType: ").Append(JoinType).Append("\n");
            sb.Append("  OnClauseTerms: ").Append(OnClauseTerms).Append("\n");
            sb.Append("  RightTableAvailableFields: ").Append(RightTableAvailableFields).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as JoinedTableDesign);
        }

        /// <summary>
        /// Returns true if JoinedTableDesign instances are equal
        /// </summary>
        /// <param name="input">Instance of JoinedTableDesign to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(JoinedTableDesign input)
        {
            if (input == null)
            {
                return false;
            }
            return 
                (
                    this.JoinedTableName == input.JoinedTableName ||
                    (this.JoinedTableName != null &&
                    this.JoinedTableName.Equals(input.JoinedTableName))
                ) && 
                (
                    this.JoinedTableAlias == input.JoinedTableAlias ||
                    (this.JoinedTableAlias != null &&
                    this.JoinedTableAlias.Equals(input.JoinedTableAlias))
                ) && 
                (
                    this.LeftTableAlias == input.LeftTableAlias ||
                    (this.LeftTableAlias != null &&
                    this.LeftTableAlias.Equals(input.LeftTableAlias))
                ) && 
                (
                    this.JoinType == input.JoinType ||
                    this.JoinType.Equals(input.JoinType)
                ) && 
                (
                    this.OnClauseTerms == input.OnClauseTerms ||
                    this.OnClauseTerms != null &&
                    input.OnClauseTerms != null &&
                    this.OnClauseTerms.SequenceEqual(input.OnClauseTerms)
                ) && 
                (
                    this.RightTableAvailableFields == input.RightTableAvailableFields ||
                    this.RightTableAvailableFields != null &&
                    input.RightTableAvailableFields != null &&
                    this.RightTableAvailableFields.SequenceEqual(input.RightTableAvailableFields)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.JoinedTableName != null)
                {
                    hashCode = (hashCode * 59) + this.JoinedTableName.GetHashCode();
                }
                if (this.JoinedTableAlias != null)
                {
                    hashCode = (hashCode * 59) + this.JoinedTableAlias.GetHashCode();
                }
                if (this.LeftTableAlias != null)
                {
                    hashCode = (hashCode * 59) + this.LeftTableAlias.GetHashCode();
                }
                hashCode = (hashCode * 59) + this.JoinType.GetHashCode();
                if (this.OnClauseTerms != null)
                {
                    hashCode = (hashCode * 59) + this.OnClauseTerms.GetHashCode();
                }
                if (this.RightTableAvailableFields != null)
                {
                    hashCode = (hashCode * 59) + this.RightTableAvailableFields.GetHashCode();
                }
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // JoinedTableName (string) maxLength
            if (this.JoinedTableName != null && this.JoinedTableName.Length > 256)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for JoinedTableName, length must be less than 256.", new [] { "JoinedTableName" });
            }

            // JoinedTableName (string) minLength
            if (this.JoinedTableName != null && this.JoinedTableName.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for JoinedTableName, length must be greater than 0.", new [] { "JoinedTableName" });
            }

            // JoinedTableAlias (string) maxLength
            if (this.JoinedTableAlias != null && this.JoinedTableAlias.Length > 256)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for JoinedTableAlias, length must be less than 256.", new [] { "JoinedTableAlias" });
            }

            // JoinedTableAlias (string) minLength
            if (this.JoinedTableAlias != null && this.JoinedTableAlias.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for JoinedTableAlias, length must be greater than 0.", new [] { "JoinedTableAlias" });
            }

            // LeftTableAlias (string) maxLength
            if (this.LeftTableAlias != null && this.LeftTableAlias.Length > 256)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for LeftTableAlias, length must be less than 256.", new [] { "LeftTableAlias" });
            }

            // LeftTableAlias (string) minLength
            if (this.LeftTableAlias != null && this.LeftTableAlias.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for LeftTableAlias, length must be greater than 0.", new [] { "LeftTableAlias" });
            }

            yield break;
        }
    }
}
